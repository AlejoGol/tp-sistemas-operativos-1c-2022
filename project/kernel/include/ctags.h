bool algoritmo_cargado_es(char * algoritmo);
bool hay_algun_proceso_ejecutando();
char * obtener_algoritmo_cargado();
int conectarse_a_cpu(char * conexion_puerto);
int main();
int obtener_grado_multiprogramacion_actual();
int pcb_get_posicion(t_pcb * pcb,t_list * lista);
int pcb_tiempo_restante_de_ejecucion(t_pcb * pcb);
t_cola_planificacion * cola_planificacion_create();
t_pcb * elegir_pcb_fifo(t_cola_planificacion * cola);
t_pcb * elegir_pcb_segun_algoritmo(t_cola_planificacion * cola);
t_pcb * elegir_pcb_sjf(t_cola_planificacion * cola);
t_pcb * pcb_menor_tiempo_restante_de_ejecucion_entre(t_pcb * pcb1,t_pcb * pcb2);
void * escuchar_conexion_cpu_dispatch();
void * escuchar_conexiones_entrantes();
void * escuchar_nueva_conexion(void * args);
void * iniciar_corto_plazo();
void * iniciar_largo_plazo();
void * iniciar_mediano_plazo();
void actualizar_grado_multiprogramacion();
void agregar_pcb_a_cola(t_pcb * pcb,t_cola_planificacion * cola);
void asignar_pid(t_pcb * pcb);
void avisar_a_pcp_que_decida();
void bajar_grado_multiprogramacion();
void cambiar_estado_pcb(t_pcb * pcb,t_pcb_estado nuevoEstado);
void cola_destroy(t_cola_planificacion * cola);
void controlar_grado_multiprogramacion();
void ejecutar_proceso(t_pcb * pcb);
void enviar_interrupcion();
void imprimir_grado_multiprogramacion_actual();
void imprimir_proceso_en_running();
void inicializar_grado_multiprogramacion();
void iniciar_conexion_cpu_dispatch();
void iniciar_planificacion();
void liberar_cpu();
void remover_pcb_de_cola(t_pcb * pcb,t_cola_planificacion * cola);
void subir_grado_multiprogramacion();
void transicion_a_new(t_pcb * pcb);
void transicion_blocked_a_ready(t_pcb * pcb);
void transicion_new_a_ready(t_pcb * pcb);
void transicion_ready_a_running(t_pcb * pcb);
void transicion_running_a_blocked(t_pcb * pcb);
void transicion_susblocked_a_susready(t_pcb * pcb);
void transicion_susready_a_ready(t_pcb * pcb);
